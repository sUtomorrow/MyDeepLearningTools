# -*- coding: utf-8 -*-
# @Time     : 9/17/19 6:20 PM
# @Author   : lty
# @File     : anchors


import numpy as np
import torch

def get_anchors(anchor_sizes, anchor_ratios):
    """
    get ori anchors by anchor sizes and anchor ratios

    :param anchor_sizes:  the base anchor sizes
    :param anchor_ratios: the ratios of w:h for each anchor size
    :return:              the anchors with different anchor size and anchor ratio, with length = len(anchor_sizes) * len(anchor_ratios)
    """

    anchor_sizes   = np.expand_dims(np.array(anchor_sizes), -1)
    anchor_ratios  = np.power(np.expand_dims(np.array(anchor_ratios), 0), 0.5)
    anchor_widths  = anchor_sizes * anchor_ratios
    anchor_heights = anchor_sizes / anchor_ratios
    anchors = np.stack([np.ravel(anchor_widths), np.ravel(anchor_heights)], axis=-1)
    return anchors


def anchor_shift(anchors, feature_size, stride):
    """
    assign anchors to each point in the feature map

    :param anchors:      the ori anchors generated by func:get_anchors
    :param feature_size: size of (h, w) for feature map
    :param stride:       the stride of feature map
    :return:             the anchor coordinate with shape (N, 4) and order [x1, y1, x2, y2]
    """
    height, width = feature_size
    anchors = np.tile(np.reshape(anchors, (1, 1, len(anchors), 2)), (height, width, 1, 1))
    x = (np.arange(0, width) + 0.5) * stride
    y = (np.arange(0, height) + 0.5) * stride
    xs, ys = np.meshgrid(x, y)
    grid = np.expand_dims(np.stack([xs, ys], axis=-1), axis=2)
    tl_coordinate = grid - anchors / 2
    br_coordinate = tl_coordinate + anchors
    anchors = np.concatenate([tl_coordinate, br_coordinate], axis=-1)
    return np.reshape(anchors, (height * width * anchors.shape[2], -1))


def _bbox_transform(anchors, gt_boxes):
    """
    transform gt boxes to anchor regression targets
    :param anchors : [x1, y1, x2, y2]
    :param gt_boxes: [bx1, by1, bx2, by2]
    ax = (x1 + x2) / 2 130
    ay = (y1 + y2) / 2
    aw = x2 - x1 235
    ah = y2 - y1

    bx = (bx1 + bx2) / 2 129
    by = (by1 + by2) / 2
    bw = bx2 - bx1
    bh = by2 - by1

    tx = (bx - ax) / aw  -11 /
    ty = (by - ay) / ah
    tw = log(bw / aw)
    th = log(bh / ah)

    return [tx, ty, tw, th]
    """
    ax = (anchors[:, 0] + anchors[:, 2]) / 2
    ay = (anchors[:, 1] + anchors[:, 3]) / 2
    aw = anchors[:, 2] - anchors[:, 0]
    ah = anchors[:, 3] - anchors[:, 1]

    bx = (gt_boxes[:, 0] + gt_boxes[:, 2]) / 2
    by = (gt_boxes[:, 1] + gt_boxes[:, 3]) / 2
    bw = gt_boxes[:, 2] - gt_boxes[:, 0]
    bh = gt_boxes[:, 3] - gt_boxes[:, 1]

    tx = (bx - ax) / aw
    ty = (by - ay) / ah
    tw = torch.log(bw / aw)
    th = torch.log(bh / ah)

    return torch.stack([tx, ty, tw, th], dim=-1)


def _bbox_transform_inv(anchors, regressions):
    """
    transform regression back to bbox by anchors
    :param anchors:     [x1, y1, x2, y2]
    :param regressions: [tx, ty, tw, th]
    ax = (x1 + x2) / 2
    ay = (y1 + y2) / 2
    aw = x2 - x1
    ah = y2 - y1

    bx = ax + tx * aw
    by = ay + ty * ah
    bw = aw * exp(tw)
    bh = ah * exp(th)

    bx1 = bx - bw / 2
    by1 = by - bh / 2
    bx2 = bx1 + bw
    by2 = by1 + bh
    return [bx1, by1, bx2, by2]
    """
    anchor_x = (anchors[:, :, 2] + anchors[:, :, 0]) / 2
    anchor_y = (anchors[:, :, 3] + anchors[:, :, 1]) / 2

    anchor_w = anchors[:, :, 2] - anchors[:, :, 0]
    anchor_h = anchors[:, :, 3] - anchors[:, :, 1]

    bbox_x = anchor_x + regressions[:, :, 0] * anchor_w
    bbox_y = anchor_y + regressions[:, :, 1] * anchor_h
    bbox_w = anchor_w * torch.exp(regressions[:, :, 2])
    bbox_h = anchor_h * torch.exp(regressions[:, :, 3])

    bbox_x1 = bbox_x - bbox_w / 2
    bbox_y1 = bbox_y - bbox_h / 2
    bbox_x2 = bbox_x1 + bbox_w
    bbox_y2 = bbox_y1 + bbox_h

    return torch.stack([bbox_x1, bbox_y1, bbox_x2, bbox_y2], dim=-1)


def overlaps(bboxes1, bboxes2):
    """
    :param bboxes1: [x1, y1, x2, y2] with shape:(M, 4)
    :param bboxes2: [x1, y1, x2, y2] with shape:(N, 4)
    :return: overlaps with shape: (M, N)
    """
    M = bboxes1.size(0)
    N = bboxes2.size(0)

    # reshape for broadcast
    bboxes1 = bboxes1.unsqueeze(1).repeat(1, N, 1)
    bboxes2 = bboxes2.unsqueeze(0).repeat(M, 1, 1)

    # print('bboxes1.size', bboxes1.size())
    # print('bboxes2.size', bboxes2.size())

    inter_x1 = torch.max(bboxes1[:, :, 0], bboxes2[:, :, 0])
    inter_x2 = torch.min(bboxes1[:, :, 2], bboxes2[:, :, 2])

    inter_y1 = torch.max(bboxes1[:, :, 1], bboxes2[:, :, 1])
    inter_y2 = torch.min(bboxes1[:, :, 3], bboxes2[:, :, 3])

    inter_w = inter_x2 - inter_x1
    inter_w[inter_w < 0] = 0
    inter_h = inter_y2 - inter_y1
    inter_h[inter_h < 0] = 0

    inter_area = inter_h * inter_w

    w1 = bboxes1[:, :, 2] - bboxes1[:, :, 0]
    w1[w1 < 0] = 0
    h1 = bboxes1[:, :, 3] - bboxes1[:, :, 1]
    h1[h1 < 0] = 0

    w2 = bboxes2[:, :, 2] - bboxes2[:, :, 0]
    w2[w2 < 0] = 0
    h2 = bboxes2[:, :, 3] - bboxes2[:, :, 1]
    h2[h2 < 0] = 0

    area1 = w1 * h1
    area2 = w2 * h2

    return inter_area / (area1 + area2 - inter_area)


class AnchorTargetLayer(torch.nn.Module):
    def __init__(self, positive_anchor_threshold, negative_anchor_threshold, max_positive_anchor, max_negative_anchor_ratio):
        """
        compute the rpn target by anchor and feature map

        :param positive_anchor_threshold: iou threshold to decide an anchor is positive(greater or equal)
        :param negative_anchor_threshold: iou threshold to decide an anchor is negative(less or equal)
        :param max_positive_anchor     : max number of positive anchor in one image, if None: no limit
        :param max_negative_anchor_ratio: max ratio, negative anchor number : positive anchor number, if None: no limit
        """
        super(AnchorTargetLayer, self).__init__()

        self.positive_anchor_threshold = positive_anchor_threshold
        self.negative_anchor_threshold = negative_anchor_threshold

        self.max_positive_anchor       = max_positive_anchor
        self.max_negative_anchor_ratio = max_negative_anchor_ratio


    def forward(self, *input):
        """
        :param input:
            anchors        : with shape (A, 4), (x1, y1, x2, y2), the anchor for each point
            batch_gt_boxes : with shape (BatchSize, max_target_number, 4), (x1, y1, x2, y2)
            batch_labels   : with shape (BatchSize, max_target_number), contain the label id for boxes
        :return: [(B, A, 5), (B, A, 2)] regression target and classification target for rpn
        """
        anchors, batch_gt_boxes, batch_labels = input
        batch_size = batch_gt_boxes.size(0)
        regression_target     = torch.zeros((batch_size, anchors.size(0), 5)).type_as(batch_gt_boxes) # [tx, ty, tw, th, weight]
        classification_target = torch.zeros((batch_size, anchors.size(0), 2)).type_as(batch_labels).long() # [background, foreground, weight]
        for batch_idx in range(batch_size):
            # compute target for each batch data
            gt_boxes = batch_gt_boxes[batch_idx]
            labels   = batch_labels[batch_idx]

            # filter the padding label and box
            indices  = labels >= 0
            gt_boxes = gt_boxes[indices]
            labels   = labels[indices]

            gt_box_number = labels.size(0)

            if gt_box_number == 0:
                # random select negative anchor to train if there is no gt
                indices = torch.randperm(classification_target.size(1))
                classification_target[batch_idx, indices[:self.max_positive_anchor // 2], -1] = 1
                # classification_target[batch_idx, indices[:self.max_positive_anchor // 2], 0] = 0
                continue

            ious = overlaps(anchors, gt_boxes)

            max_anchor_ious, anchor_max_iou_gt_box_indices = torch.max(ious, 1)

            positive_anchor_mask    = max_anchor_ious >= self.positive_anchor_threshold
            negative_anchor_mask    = max_anchor_ious <= self.negative_anchor_threshold
            positive_anchor_indices = torch.nonzero(positive_anchor_mask)
            negative_anchor_indices = torch.nonzero(negative_anchor_mask)
            # ignore_anchor_indices   = torch.nonzero(~(positive_anchor_mask | negative_anchor_mask))

            if self.max_positive_anchor:
                if positive_anchor_indices.size(0) > self.max_positive_anchor:
                    # random choice to filter the positive anchor with max positive number
                    indices = torch.randperm(positive_anchor_indices.size(0))
                    positive_anchor_indices = positive_anchor_indices[indices[:self.max_positive_anchor]]

            if self.max_negative_anchor_ratio:
                max_negative_anchor = int(self.max_negative_anchor_ratio * len(positive_anchor_indices))

                if negative_anchor_indices.size(0) > max_negative_anchor:
                    # random choice to filter the negative anchor with max negative number
                    indices = torch.randperm(negative_anchor_indices.size(0))
                    negative_anchor_indices = negative_anchor_indices[indices[:max_negative_anchor]]

            # compute all anchor regression targets
            anchor_regression_target = _bbox_transform(anchors, gt_boxes[anchor_max_iou_gt_box_indices])

            # assign weight for anchors, default 0 for ignore this anchor
            regression_target[batch_idx, positive_anchor_indices, -1] = 1

            classification_target[batch_idx, positive_anchor_indices, -1] = 1
            classification_target[batch_idx, negative_anchor_indices, -1] = 1


            # assign regression target and classification target
            regression_target[batch_idx, positive_anchor_indices, :-1]   = anchor_regression_target[positive_anchor_indices, :]

            # if positive_anchor_indices.size(0) > 2:
            # print('positive anchor num:', positive_anchor_indices.size(0))
            # print('negative anchor num:', negative_anchor_indices.size(0))
            #     print('anchor gt    ', gt_boxes[anchor_max_iou_gt_box_indices][positive_anchor_indices, :][:2])
            #     print('anchor       ', anchors[positive_anchor_indices, :][:2])
            #     print('anchor target', regression_target[batch_idx, positive_anchor_indices, :][:2])

            classification_target[batch_idx, positive_anchor_indices, 0] = 1  # rpn use label idx 1 as classification target for foreground

            # classification_target[batch_idx, negative_anchor_indices, 0] = 0 # do not need assign value
        return [regression_target, classification_target]

if __name__ == '__main__':
    """test anchor generate"""

    anchors = get_anchors([4, 8], anchor_ratios=[0.5, 2.0])
    print(anchors)
    # [[ 2.82842712  5.65685425]
    #  [ 5.65685425  2.82842712]
    #  [ 5.65685425 11.3137085 ]
    #  [11.3137085   5.65685425]]

    anchors = anchor_shift(anchors, (2, 2), 8)
    print(anchors)
    # [[[[ 2.58578644  1.17157288  5.41421356  6.82842712]
    #    [ 1.17157288  2.58578644  6.82842712  5.41421356]
    #    [ 1.17157288 -1.65685425  6.82842712  9.65685425]
    #    [-1.65685425  1.17157288  9.65685425  6.82842712]]
    #
    #   [[10.58578644  1.17157288 13.41421356  6.82842712]
    #    [ 9.17157288  2.58578644 14.82842712  5.41421356]
    #    [ 9.17157288 -1.65685425 14.82842712  9.65685425]
    #    [ 6.34314575  1.17157288 17.65685425  6.82842712]]]
    #
    #
    #  [[[ 2.58578644  9.17157288  5.41421356 14.82842712]
    #    [ 1.17157288 10.58578644  6.82842712 13.41421356]
    #    [ 1.17157288  6.34314575  6.82842712 17.65685425]
    #    [-1.65685425  9.17157288  9.65685425 14.82842712]]
    #
    #   [[10.58578644  9.17157288 13.41421356 14.82842712]
    #    [ 9.17157288 10.58578644 14.82842712 13.41421356]
    #    [ 9.17157288  6.34314575 14.82842712 17.65685425]
    #    [ 6.34314575  9.17157288 17.65685425 14.82842712]]]]